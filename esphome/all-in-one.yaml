substitutions:
  device_name: esp32-garage-all-in-one
  friendly_name: "Garage All-in-One"
  firmware_version: "0.1.1"
  
  # Car Positioning Settings
  # Garage Door sensor is ceiling-mounted: Y = distance from ceiling to car top; X = lateral offset
  front_target_y_min: "19.7"   # calibrate: (ceiling_height_in - car_height_in) - tolerance
  front_target_y_max: "31.5"
  front_target_x_tolerance: "7.9"
  # Inside Wall sensor is wall-mounted: Y = distance from inside wall into garage; X = height
  rear_target_y_min: "70.9"    # desired parking depth from back wall (inches)
  rear_target_y_max: "86.6"
  rear_target_x_tolerance: "11.8"
  num_leds: "60"
  person_max_distance: "59.1"
  danger_zone_distance: "118.1"

  # Garage Door Settings
  garage_door_full_open_counts: "64"   # adjust to your measured door travel

  # GPIO Assignments for ESP32-C6 DevKit (All-in-One)
  # See docs/hardware/ESP32-C6 DevKit.md for pinout details
  led_strip_pin: GPIO0
  garage_door_closed_switch_pin: GPIO1
  garage_door_encoder_a_pin: GPIO2
  garage_door_encoder_b_pin: GPIO3
  garage_door_relay_pin: GPIO10
  ld2450_front_rx_pin: GPIO16
  ld2450_front_tx_pin: GPIO17
  ld2450_rear_rx_pin: GPIO18
  ld2450_rear_tx_pin: GPIO19

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  comment: "Garage all-in-one: car positioning + door control v${firmware_version}"
  platformio_options:
    board_build.flash_mode: dio
  on_boot:
    priority: -100
    then:
      - lambda: |-
          id(boot_count) += 1;
          ESP_LOGI("boot", "Boot count: %d", id(boot_count));
          if (id(garage_door_closed_switch).state) {
            id(door_counts) = 0;
          }
      - light.turn_off: garage_parking_led

globals:
  - id: boot_count
    type: int
    restore_value: true
    initial_value: '0'
  - id: scan_position
    type: int
    initial_value: '0'
  - id: scan_forward
    type: bool
    initial_value: 'true'
  - id: led_auto_mode
    type: bool
    restore_value: false
    initial_value: 'true'
  - id: door_counts
    type: int
    restore_value: true
    initial_value: '0'

esp32:
  board: esp32-c6-devkitc-1
  variant: esp32c6
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP_WIFI_ENABLE_WPA3_SAE: "n"
      CONFIG_ESP_WIFI_ENABLE_SAE_PK: "n"
      CONFIG_ESP_WIFI_SOFTAP_SAE_SUPPORT: "n"
      CONFIG_ESP_WIFI_ENABLE_WPA3_OWE_STA: "n"

logger:
  level: WARN
  hardware_uart: USB_SERIAL_JTAG

# Garage Door LD2450 UART - GPIO16 (RX from sensor TX), GPIO17 (TX to sensor RX)
# Inside Wall LD2450 UART - GPIO18 (RX from sensor TX), GPIO19 (TX to sensor RX)
uart:
  - id: uart_ld2450_front
    rx_pin: ${ld2450_front_rx_pin}
    tx_pin: ${ld2450_front_tx_pin}
    baud_rate: 256000
    parity: NONE
    stop_bits: 1

  - id: uart_ld2450_rear
    rx_pin: ${ld2450_rear_rx_pin}
    tx_pin: ${ld2450_rear_tx_pin}
    baud_rate: 256000
    parity: NONE
    stop_bits: 1

ld2450:
  - id: ld2450_front
    uart_id: uart_ld2450_front
  - id: ld2450_rear
    uart_id: uart_ld2450_rear

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: 15min
  power_save_mode: none
  enable_on_boot: true
  fast_connect: on
  output_power: 8.5dBm
  ap:
    ssid: "garage-all-in-one"
    password: !secret ap_password

api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

captive_portal:

web_server:
  port: 80
  version: 3
  include_internal: false
  sorting_groups:
    - id: group_car
      name: "Car Positioning"
      sorting_weight: 1
    - id: group_door
      name: "Garage Door"
      sorting_weight: 2
    - id: group_config
      name: "Configuration"
      sorting_weight: 3
    - id: group_diag
      name: "Diagnostic"
      sorting_weight: 4

sensor:
  # === SYSTEM SENSORS ===
  - platform: uptime
    name: "System - Uptime Seconds"
    id: uptime_sensor
    internal: true

  - platform: template
    name: "System - Boot Count"
    id: boot_count_sensor
    icon: "mdi:counter"
    accuracy_decimals: 0
    lambda: |-
      return id(boot_count);
    update_interval: 60s
    web_server:
      sorting_group_id: group_diag
      sorting_weight: 3

  # === CAR POSITION - GARAGE DOOR SENSORS ===
  - platform: ld2450
    ld2450_id: ld2450_front
    target_count:
      name: "Car Position - Garage Door Target Count"
      id: front_target_count
      web_server:
        sorting_group_id: group_diag
        sorting_weight: 10
    target_1:
      x:
        name: "Car Position - Garage Door T1 X"
        id: front_x
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
        web_server:
          sorting_group_id: group_diag
          sorting_weight: 11
      y:
        name: "Car Position - Garage Door T1 Y"
        id: front_y
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
        web_server:
          sorting_group_id: group_diag
          sorting_weight: 12
      distance:
        name: "Car Position - Garage Door T1 Distance"
        id: front_distance
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
        web_server:
          sorting_group_id: group_diag
          sorting_weight: 13
      speed:
        name: "Car Position - Garage Door T1 Speed"
        id: front_speed
        unit_of_measurement: "in/s"
        accuracy_decimals: 1
        filters:
          - multiply: 0.3937
        web_server:
          sorting_group_id: group_diag
          sorting_weight: 14
    target_2:
      x:
        name: "Car Position - Garage Door T2 X"
        id: front_t2_x
        unit_of_measurement: "in"
        filters:
          - multiply: 0.03937
        internal: true
      y:
        name: "Car Position - Garage Door T2 Y"
        id: front_t2_y
        unit_of_measurement: "in"
        filters:
          - multiply: 0.03937
        internal: true
      distance:
        name: "Car Position - Garage Door T2 Distance"
        id: front_t2_distance
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
        web_server:
          sorting_group_id: group_diag
          sorting_weight: 15

  # === CAR POSITION - INSIDE WALL SENSORS ===
  - platform: ld2450
    ld2450_id: ld2450_rear
    target_count:
      name: "Car Position - Inside Wall Target Count"
      id: rear_target_count
      web_server:
        sorting_group_id: group_diag
        sorting_weight: 20
    target_1:
      x:
        name: "Car Position - Inside Wall T1 X"
        id: rear_x
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
        web_server:
          sorting_group_id: group_diag
          sorting_weight: 21
      y:
        name: "Car Position - Inside Wall T1 Y"
        id: rear_y
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
        web_server:
          sorting_group_id: group_diag
          sorting_weight: 22
      distance:
        name: "Car Position - Inside Wall T1 Distance"
        id: rear_distance
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
        web_server:
          sorting_group_id: group_diag
          sorting_weight: 23
      speed:
        name: "Car Position - Inside Wall T1 Speed"
        id: rear_speed
        unit_of_measurement: "in/s"
        accuracy_decimals: 1
        filters:
          - multiply: 0.3937
        web_server:
          sorting_group_id: group_diag
          sorting_weight: 24
    target_2:
      x:
        name: "Car Position - Inside Wall T2 X"
        id: rear_t2_x
        unit_of_measurement: "in"
        filters:
          - multiply: 0.03937
        internal: true
      y:
        name: "Car Position - Inside Wall T2 Y"
        id: rear_t2_y
        unit_of_measurement: "in"
        filters:
          - multiply: 0.03937
        internal: true
      distance:
        name: "Car Position - Inside Wall T2 Distance"
        id: rear_t2_distance
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
        web_server:
          sorting_group_id: group_diag
          sorting_weight: 25

  # === CAR POSITION - COMPUTED ===
  # car_center_y reports the rear (wall-mounted) sensor Y: distance from back wall into garage.
  # This is the physically meaningful depth axis for parking guidance.
  # Falls back to front (ceiling) Y only when rear is unavailable.
  - platform: template
    name: "Car Position - Distance from Inside Wall"
    id: car_center_y
    unit_of_measurement: "in"
    accuracy_decimals: 1
    icon: "mdi:car"
    lambda: |-
      bool rear_valid = !isnan(id(rear_distance).state) && id(rear_distance).state > 0;
      bool front_valid = !isnan(id(front_distance).state) && id(front_distance).state > 0;
      if (rear_valid) return id(rear_y).state;
      if (front_valid) return id(front_y).state;
      return NAN;
    update_interval: 500ms
    web_server:
      sorting_group_id: group_car
      sorting_weight: 6

  # car_center_x reports the front (ceiling-mounted) sensor X: lateral offset of the car.
  # Positive = one side, negative = other side (confirm direction by testing on hardware).
  # Falls back to rear X only when front is unavailable.
  - platform: template
    name: "Car Centering"
    id: car_center_x
    unit_of_measurement: "in"
    accuracy_decimals: 1
    icon: "mdi:car-side"
    lambda: |-
      bool front_valid = !isnan(id(front_distance).state) && id(front_distance).state > 0;
      bool rear_valid = !isnan(id(rear_distance).state) && id(rear_distance).state > 0;
      if (front_valid) return id(front_x).state;
      if (rear_valid) return id(rear_x).state;
      return NAN;
    update_interval: 500ms
    web_server:
      sorting_group_id: group_car
      sorting_weight: 7

  # === GARAGE DOOR POSITION ===
  # Quadrature encoder: counts A-sensor edges, direction determined by B-sensor state.
  # Resets to 0 when closed switch triggers. Calibrate via garage_door_full_open_counts.
  - platform: template
    name: "Garage Door - Position"
    id: door_position_pct
    unit_of_measurement: "%"
    icon: "mdi:garage"
    accuracy_decimals: 0
    lambda: |-
      float pct = (float)id(door_counts) / (float)${garage_door_full_open_counts} * 100.0f;
      return std::min(100.0f, std::max(0.0f, pct));
    update_interval: 500ms
    web_server:
      sorting_group_id: group_door
      sorting_weight: 3

number:
  - platform: template
    name: "Car Position - LED Active Count"
    id: active_led_count
    icon: "mdi:led-on"
    min_value: 1
    max_value: 60
    step: 1
    initial_value: ${num_leds}
    restore_value: true
    optimistic: true
    set_action:
      - logger.log:
          format: "LED count set to %.0f"
          args: ['x']
    web_server:
      sorting_group_id: group_config
      sorting_weight: 2

binary_sensor:
  # === CAR POSITION - DETECTION ===
  - platform: template
    name: "Car Position - Vehicle Detected"
    id: car_detected
    device_class: occupancy
    icon: "mdi:car"
    lambda: |-
      float front_dist = id(front_distance).state;
      float rear_dist = id(rear_distance).state;
      bool front_valid = !isnan(front_dist) && front_dist > 20;
      bool rear_valid = !isnan(rear_dist) && rear_dist > 20;
      return front_valid || rear_valid;
    filters:
      - delayed_on: 1s
      - delayed_off: 5s
    web_server:
      sorting_group_id: group_car
      sorting_weight: 3

  - platform: template
    name: "Car Position - Person Detected"
    id: person_detected
    device_class: motion
    icon: "mdi:walk"
    lambda: |-
      float front_dist = id(front_distance).state;
      float rear_dist = id(rear_distance).state;
      float front_spd = abs(id(front_speed).state);
      float rear_spd = abs(id(rear_speed).state);
      float max_dist = ${person_max_distance};

      bool front_person = !isnan(front_dist) && front_dist > 4 && front_dist < max_dist && front_spd < 20;
      bool rear_person = !isnan(rear_dist) && rear_dist > 4 && rear_dist < max_dist && rear_spd < 20;

      return (front_person || rear_person) && !id(car_detected).state;
    filters:
      - delayed_on: 500ms
      - delayed_off: 2s
    web_server:
      sorting_group_id: group_car
      sorting_weight: 4

  - platform: template
    name: "Car Position - Person in Danger Zone"
    id: person_in_danger_zone
    device_class: safety
    icon: "mdi:alert"
    lambda: |-
      if (!id(car_detected).state) return false;

      float danger_dist = ${danger_zone_distance};

      float front_t2_dist = id(front_t2_distance).state;
      bool front_danger = !isnan(front_t2_dist) && front_t2_dist > 4 && front_t2_dist < danger_dist;

      float rear_t2_dist = id(rear_t2_distance).state;
      bool rear_danger = !isnan(rear_t2_dist) && rear_t2_dist > 4 && rear_t2_dist < danger_dist;

      return front_danger || rear_danger;
    filters:
      - delayed_on: 300ms
      - delayed_off: 1s
    web_server:
      sorting_group_id: group_car
      sorting_weight: 5
    on_press:
      - logger.log:
          format: "*** DANGER: Person in danger zone! ***"
          level: WARN
      - light.turn_on:
          id: garage_parking_led
          effect: "Person Alert (Red Flash)"
    on_release:
      - logger.log:
          format: "*** Danger zone clear ***"
          level: INFO
      - light.turn_off: garage_parking_led

  - platform: template
    name: "Car Position - Correctly Parked"
    id: car_correctly_parked
    device_class: occupancy
    icon: "mdi:car-select"
    lambda: |-
      if (!id(car_detected).state) return false;
      bool front_valid = !isnan(id(front_distance).state) && id(front_distance).state > 0;
      bool rear_valid  = !isnan(id(rear_distance).state)  && id(rear_distance).state  > 0;
      // Front sensor (ceiling): Y = ceiling-to-car-top distance; X = lateral offset
      bool front_ok = front_valid
        && (id(front_y).state >= ${front_target_y_min})
        && (id(front_y).state <= ${front_target_y_max})
        && abs(id(front_x).state) <= ${front_target_x_tolerance};
      // Rear sensor (wall): Y = depth from back wall; X = height (not used for parking check)
      bool rear_ok = rear_valid
        && (id(rear_y).state >= ${rear_target_y_min})
        && (id(rear_y).state <= ${rear_target_y_max});
      return front_ok && rear_ok;
    web_server:
      sorting_group_id: group_car
      sorting_weight: 2

  # === GARAGE DOOR SENSORS ===
  - platform: gpio
    name: "Garage Door - Closed Switch"
    id: garage_door_closed_switch
    pin:
      number: ${garage_door_closed_switch_pin}
      mode: INPUT_PULLUP
      inverted: true
    device_class: door
    on_press:
      - logger.log:
          format: "*** Garage Door: CLOSED ***"
          level: INFO
      - lambda: 'id(door_counts) = 0;'
    on_release:
      - logger.log:
          format: "*** Garage Door: OPENED ***"
          level: INFO
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    web_server:
      sorting_group_id: group_door
      sorting_weight: 2

  - platform: gpio
    name: "Garage Door - Hall Sensor A"
    id: hall_sensor_a
    pin:
      number: ${garage_door_encoder_a_pin}
      mode: INPUT_PULLUP
      inverted: true
    device_class: occupancy
    on_press:
      - logger.log:
          format: "*** Hall Sensor A: TRIGGERED ***"
          level: INFO
      - lambda: |-
          int delta = id(hall_sensor_b).state ? -1 : 1;
          id(door_counts) = std::max(0, id(door_counts) + delta);
          ESP_LOGD("door", "Door counts: %d (A high, B %s)", id(door_counts), id(hall_sensor_b).state ? "high" : "low");
    on_release:
      - logger.log:
          format: "*** Hall Sensor A: CLEARED ***"
          level: INFO
      - lambda: |-
          int delta = id(hall_sensor_b).state ? 1 : -1;
          id(door_counts) = std::max(0, id(door_counts) + delta);
          ESP_LOGD("door", "Door counts: %d (A low, B %s)", id(door_counts), id(hall_sensor_b).state ? "high" : "low");
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    web_server:
      sorting_group_id: group_diag
      sorting_weight: 30

  - platform: gpio
    name: "Garage Door - Hall Sensor B"
    id: hall_sensor_b
    pin:
      number: ${garage_door_encoder_b_pin}
      mode: INPUT_PULLUP
      inverted: true
    device_class: occupancy
    on_press:
      - logger.log:
          format: "*** Hall Sensor B: TRIGGERED ***"
          level: INFO
    on_release:
      - logger.log:
          format: "*** Hall Sensor B: CLEARED ***"
          level: INFO
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    web_server:
      sorting_group_id: group_diag
      sorting_weight: 31

button:
  - platform: restart
    name: "System - Restart Device"
    icon: "mdi:restart"
    web_server:
      sorting_group_id: group_diag
      sorting_weight: 2

switch:
  - platform: template
    name: "Car Position - LED Auto Mode"
    id: led_auto_mode_switch
    icon: "mdi:led-on"
    optimistic: false
    lambda: |-
      return id(led_auto_mode);
    turn_on_action:
      - globals.set:
          id: led_auto_mode
          value: 'true'
    turn_off_action:
      - globals.set:
          id: led_auto_mode
          value: 'false'
      - light.turn_off: garage_parking_led
    web_server:
      sorting_group_id: group_config
      sorting_weight: 1

  # Garage Door Relay — momentary pulse, auto-off after 200ms
  - platform: gpio
    name: "Garage Door - Open / Close"
    pin: ${garage_door_relay_pin}
    id: garage_door_relay
    icon: "mdi:garage-open-variant"
    restore_mode: ALWAYS_OFF
    web_server:
      sorting_group_id: group_config
      sorting_weight: 4
    on_turn_on:
      - delay: 200ms
      - switch.turn_off: garage_door_relay

  - platform: template
    name: "System - Debug Logging"
    id: debug_logging_switch
    icon: "mdi:bug"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - logger.set_level:
          level: DEBUG
    turn_off_action:
      - logger.set_level:
          level: WARN
    web_server:
      sorting_group_id: group_config
      sorting_weight: 5

# LED Strip
light:
  - platform: esp32_rmt_led_strip
    name: "Car Position - Parking LED"
    id: garage_parking_led
    pin: ${led_strip_pin}
    num_leds: ${num_leds}
    chipset: WS2812
    restore_mode: ALWAYS_OFF
    rgb_order: GRB
    default_transition_length: 500ms
    web_server:
      sorting_group_id: group_config
      sorting_weight: 3
    effects:
      - addressable_lambda:
          name: "Solid"
          update_interval: 100ms
          lambda: |-
            int count = id(active_led_count).state;
            for (int i = 0; i < it.size(); i++) {
              if (i < count) {
                it[i] = current_color;
              } else {
                it[i] = Color::BLACK;
              }
            }

      - addressable_lambda:
          name: "Parked (Green)"
          update_interval: 100ms
          lambda: |-
            int count = id(active_led_count).state;
            for (int i = 0; i < it.size(); i++) {
              it[i] = (i < count) ? Color(0, 255, 0) : Color::BLACK;
            }

      - addressable_lambda:
          name: "Move Forward (Blue Scan)"
          update_interval: 40ms
          lambda: |-
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;

            int pos = id(scan_position);
            int trail_length = 5;

            for (int i = 0; i < trail_length && (pos - i) >= 0; i++) {
              int idx = pos - i;
              if (idx < count) {
                uint8_t brightness = 255 - (i * 40);
                it[idx] = Color(0, 0, brightness);
              }
            }

            id(scan_position) = (pos + 1) % count;

      - addressable_lambda:
          name: "Move Forward Minor (Cyan Scan)"
          update_interval: 80ms
          lambda: |-
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;

            int pos = id(scan_position);
            int trail_length = 3;

            for (int i = 0; i < trail_length && (pos - i) >= 0; i++) {
              int idx = pos - i;
              if (idx < count) {
                uint8_t brightness = 255 - (i * 60);
                it[idx] = Color(0, brightness, brightness);
              }
            }

            id(scan_position) = (pos + 1) % count;

      - addressable_lambda:
          name: "Move Back (Orange Scan)"
          update_interval: 40ms
          lambda: |-
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;

            int pos = id(scan_position);
            int trail_length = 5;

            for (int i = 0; i < trail_length && (pos + i) < count; i++) {
              int idx = pos + i;
              if (idx >= 0) {
                uint8_t brightness = 255 - (i * 40);
                it[idx] = Color(brightness, brightness / 4, 0);
              }
            }

            id(scan_position) = pos - 1;
            if (id(scan_position) < 0) {
              id(scan_position) = count - 1;
            }

      - addressable_lambda:
          name: "Move Back Minor (Yellow Scan)"
          update_interval: 80ms
          lambda: |-
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;

            int pos = id(scan_position);
            int trail_length = 3;

            for (int i = 0; i < trail_length && (pos + i) < count; i++) {
              int idx = pos + i;
              if (idx >= 0) {
                uint8_t brightness = 255 - (i * 60);
                it[idx] = Color(brightness, brightness, 0);
              }
            }

            id(scan_position) = pos - 1;
            if (id(scan_position) < 0) {
              id(scan_position) = count - 1;
            }

      - addressable_lambda:
          name: "Person Alert (Red Flash)"
          update_interval: 250ms
          lambda: |-
            static bool flash_on = false;
            int count = id(active_led_count).state;

            flash_on = !flash_on;
            Color c = flash_on ? Color(255, 0, 0) : Color::BLACK;

            for (int i = 0; i < it.size(); i++) {
              it[i] = (i < count) ? c : Color::BLACK;
            }

      - addressable_lambda:
          name: "Rainbow"
          update_interval: 50ms
          lambda: |-
            static int offset = 0;
            int count = id(active_led_count).state;
            for (int i = 0; i < it.size(); i++) {
              if (i < count) {
                int hue = (i * 255 / count + offset) % 256;
                int region = hue / 43;
                int remainder = (hue - (region * 43)) * 6;
                uint8_t q = 255 - remainder;
                uint8_t t = remainder;
                uint8_t r, g, b;
                switch (region) {
                  case 0: r = 255; g = t; b = 0; break;
                  case 1: r = q; g = 255; b = 0; break;
                  case 2: r = 0; g = 255; b = t; break;
                  case 3: r = 0; g = q; b = 255; break;
                  case 4: r = t; g = 0; b = 255; break;
                  default: r = 255; g = 0; b = q; break;
                }
                it[i] = Color(r, g, b);
              } else {
                it[i] = Color::BLACK;
              }
            }
            offset = (offset + 2) % 256;

      - pulse:
          name: "Pulse"
          min_brightness: 20%
          max_brightness: 100%

text_sensor:
  # === SYSTEM TEXT SENSORS ===
  - platform: wifi_info
    mac_address:
      name: "System - MAC Address"
      icon: "mdi:network"
      web_server:
        sorting_group_id: group_diag
        sorting_weight: 4

  - platform: template
    name: "System - Reset Reason"
    id: reset_reason_sensor
    icon: "mdi:information"
    lambda: |-
      switch (esp_reset_reason()) {
        case ESP_RST_POWERON: return std::string("Power-on");
        case ESP_RST_EXT: return std::string("External pin");
        case ESP_RST_SW: return std::string("Software reset");
        case ESP_RST_PANIC: return std::string("Exception/panic");
        case ESP_RST_INT_WDT: return std::string("Interrupt watchdog");
        case ESP_RST_TASK_WDT: return std::string("Task watchdog");
        case ESP_RST_WDT: return std::string("Other watchdog");
        case ESP_RST_DEEPSLEEP: return std::string("Deep sleep wake");
        case ESP_RST_BROWNOUT: return std::string("Brownout");
        case ESP_RST_SDIO: return std::string("SDIO");
        default: return std::string("Unknown");
      }
    update_interval: never
    web_server:
      sorting_group_id: group_diag
      sorting_weight: 5

  - platform: template
    name: "System - Uptime"
    icon: "mdi:clock-outline"
    lambda: |-
      int seconds = (int) id(uptime_sensor).state;
      int weeks = seconds / 604800;
      seconds = seconds % 604800;
      int days = seconds / 86400;
      seconds = seconds % 86400;
      int hours = seconds / 3600;
      seconds = seconds % 3600;
      int minutes = seconds / 60;
      if (weeks > 0) {
        return str_sprintf("%dw %dd %dh %dm", weeks, days, hours, minutes);
      } else if (days > 0) {
        return str_sprintf("%dd %dh %dm", days, hours, minutes);
      } else if (hours > 0) {
        return str_sprintf("%dh %dm", hours, minutes);
      } else {
        return str_sprintf("%dm", minutes);
      }
    update_interval: 60s
    web_server:
      sorting_group_id: group_diag
      sorting_weight: 1

  - platform: version
    name: "System - ESPHome Version"
    icon: "mdi:home-assistant"
    web_server:
      sorting_group_id: group_diag
      sorting_weight: 6

  - platform: template
    name: "System - Firmware Version"
    icon: "mdi:tag"
    lambda: 'return {"${firmware_version}"};'
    update_interval: never
    web_server:
      sorting_group_id: group_diag
      sorting_weight: 7

  # === GARAGE DOOR STATUS ===
  - platform: template
    name: "Garage Door - Status"
    id: door_status
    icon: "mdi:garage"
    lambda: |-
      if (id(garage_door_closed_switch).state) return {"Closed"};
      int pct = (int)id(door_position_pct).state;
      return str_sprintf("Open %d%%", pct);
    update_interval: 500ms
    web_server:
      sorting_group_id: group_door
      sorting_weight: 1

  # === CAR POSITION TEXT SENSORS ===
  - platform: template
    name: "Car Position - Parking Guidance"
    id: parking_guidance
    icon: "mdi:parking"
    web_server:
      sorting_group_id: group_car
      sorting_weight: 1
    lambda: |-
      if (id(person_in_danger_zone).state) {
        return {"!!! STOP - PERSON !!!"};
      }
      if (id(person_detected).state) {
        return {"PERSON DETECTED"};
      }
      if (!id(car_detected).state) {
        return {"No vehicle"};
      }
      if (id(car_correctly_parked).state) {
        return {"PARKED"};
      }
      // Use rear sensor Y (wall-mounted) for depth guidance — measures parking distance from back wall
      float y = id(rear_y).state;
      if (isnan(y)) return {"Acquiring..."};
      float target = (${rear_target_y_min} + ${rear_target_y_max}) / 2.0;
      float zone = (${rear_target_y_max} - ${rear_target_y_min}) / 2.0;
      if (y < target - zone - 12) return {"MOVE FORWARD >>>"};
      if (y < target - zone) return {"Move forward >"};
      if (y > target + zone + 12) return {"<<< MOVE BACK"};
      if (y > target + zone) return {"< Move back"};
      return {"Almost there..."};
    update_interval: 500ms
    on_value:
      - if:
          condition:
            lambda: 'return id(led_auto_mode);'
          then:
            - if:
                condition:
                  lambda: 'return x == "PARKED";'
                then:
                  - light.turn_on:
                      id: garage_parking_led
                      effect: "Parked (Green)"
            - if:
                condition:
                  lambda: 'return x == "MOVE FORWARD >>>" || x == "Move forward >";'
                then:
                  - light.turn_on:
                      id: garage_parking_led
                      effect: "Move Forward (Blue Scan)"
            - if:
                condition:
                  lambda: 'return x == "<<< MOVE BACK" || x == "< Move back";'
                then:
                  - light.turn_on:
                      id: garage_parking_led
                      effect: "Move Back (Orange Scan)"
            - if:
                condition:
                  lambda: 'return x == "Almost there...";'
                then:
                  - light.turn_on:
                      id: garage_parking_led
                      effect: "Move Forward Minor (Cyan Scan)"
            - if:
                condition:
                  lambda: 'return x == "No vehicle" || x == "Acquiring...";'
                then:
                  - light.turn_off: garage_parking_led
