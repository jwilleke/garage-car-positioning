substitutions:
  device_name: garage-car-sensor
  friendly_name: "Garage Car Sensor"

  # Car Positioning Settings
  target_y_min: "1800"
  target_y_max: "2200"
  target_x_tolerance: "300"
  num_leds: "30" # Number of LEDs in your WS2812B strip

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  platformio_options:
    board_build.flash_mode: dio

esp32:
  board: esp32-c6-devkitc-1
  variant: esp32c6
  framework:
    type: esp-idf
    version: recommended

logger:
  level: DEBUG

api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "${device_name}-AP"
    password: !secret ap_password

captive_portal:

uart:
  - id: uart_ld2450_front
    rx_pin: GPIO16
    tx_pin: GPIO17
    baud_rate: 256000
    parity: NONE
    stop_bits: 1
    
  - id: uart_ld2450_rear
    rx_pin: GPIO18
    tx_pin: GPIO19
    baud_rate: 256000
    parity: NONE
    stop_bits: 1

ld2450:
  - id: ld2450_front
    uart_id: uart_ld2450_front
  - id: ld2450_rear
    uart_id: uart_ld2450_rear

sensor:
  - platform: ld2450
    ld2450_id: ld2450_front
    target_count:
      name: "Front Sensor Target Count"
    target_1:
      x:
        name: "Front Target X"
        id: front_x
      y:
        name: "Front Target Y"
        id: front_y
      distance:
        name: "Front Target Distance"
        id: front_distance

  - platform: ld2450
    ld2450_id: ld2450_rear
    target_count:
      name: "Rear Sensor Target Count"
    target_1:
      x:
        name: "Rear Target X"
        id: rear_x
      y:
        name: "Rear Target Y"
        id: rear_y
      distance:
        name: "Rear Target Distance"
        id: rear_distance

  - platform: template
    name: "Car Center X Position"
    id: car_center_x
    unit_of_measurement: "mm"
    lambda: |-
      bool front_valid = !isnan(id(front_x).state) && id(front_x).state != 0;
      bool rear_valid = !isnan(id(rear_x).state) && id(rear_x).state != 0;

      if (front_valid && rear_valid) {
        return (id(front_x).state + id(rear_x).state) / 2.0;
      } else if (front_valid) {
        return id(front_x).state;
      } else if (rear_valid) {
        return id(rear_x).state;
      }
      return NAN;
    update_interval: 500ms

  - platform: template
    name: "Car Center Y Position"
    id: car_center_y
    unit_of_measurement: "mm"
    lambda: |-
      bool front_valid = !isnan(id(front_y).state) && id(front_y).state != 0;
      bool rear_valid = !isnan(id(rear_y).state) && id(rear_y).state != 0;

      if (front_valid && rear_valid) {
        return (id(front_y).state + id(rear_y).state) / 2.0;
      } else if (front_valid) {
        return id(front_y).state;
      } else if (rear_valid) {
        return id(rear_y).state;
      }
      return NAN;
    update_interval: 500ms

binary_sensor:
  - platform: template
    name: "Car Detected"
    id: car_detected
    device_class: occupancy
    lambda: |-
      return (id(front_distance).state > 100) || (id(rear_distance).state > 100);
    filters:
      - delayed_on: 1s
      - delayed_off: 5s

  - platform: template
    name: "Car Correctly Parked"
    id: car_correctly_parked
    device_class: occupancy
    lambda: |-
      float y = id(car_center_y).state;
      float x = abs(id(car_center_x).state);
      bool y_ok = (y >= ${target_y_min}) && (y <= ${target_y_max});
      bool x_ok = x <= ${target_x_tolerance};
      return id(car_detected).state && y_ok && x_ok;

light:
  - platform: esp32_rmt
    name: "Garage Parking LED Strip"
    chipset: WS2812B
    pin: GPIO0 # Ensure this pin is not used by other components
    num_leds: ${num_leds}
    rgb_order: GRB
    id: garage_parking_led
    default_transition_length: 1s
    effects:
      - addressable_lambda:
          name: Parking Guidance Effect
          update_interval: 200ms # Update frequently for smooth feedback
          lambda: |-
            // If car not detected, turn off LEDs
            if (!id(car_detected).state) {
              it.all().set(0, 0, 0); // Off
            } 
            // If car is correctly parked, set to green
            else if (id(car_correctly_parked).state) {
              it.all().set(0, 255, 0); // Green
            } 
            // Car detected but not correctly parked, provide guidance based on Y position
            else {
              float y = id(car_center_y).state;
              float target_y_min_f = std::stof("${target_y_min}");
              float target_y_max_f = std::stof("${target_y_max}");
              float target_y_mid = (target_y_min_f + target_y_max_f) / 2.0;
              
              // Define zones for color guidance (these values can be fine-tuned)
              float perfect_zone_half_width = (target_y_max_f - target_y_min_f) / 2.0;
              float approach_zone_half_width = perfect_zone_half_width + 300.0; // 300mm beyond perfect zone

              if (y < target_y_mid - approach_zone_half_width) {
                // Too far forward
                it.all().set(0, 0, 255); // Blue (Move FORWARD)
              } else if (y > target_y_mid + approach_zone_half_width) {
                // Too far back
                it.all().set(255, 69, 0); // OrangeRed (Move BACK)
              } else if (y < target_y_mid - perfect_zone_half_width) {
                // Approaching from front (within approach zone, but not perfect)
                it.all().set(0, 255, 255); // Cyan (Minor FORWARD)
              } else if (y > target_y_mid + perfect_zone_half_width) {
                // Approaching from back (within approach zone, but not perfect)
                it.all().set(255, 255, 0); // Yellow (Minor BACK)
              } else {
                // Fallback (should be covered by car_correctly_parked, but good to have)
                it.all().set(255, 255, 255); // White (Indicates detection, unclear guidance)
              }
            }
text_sensor:
  - platform: template
    name: "Parking Guidance"
    lambda: |-
      if (!id(car_detected).state) {
        return {"No car detected"};
      }
      if (id(car_correctly_parked).state) {
        return {"âœ… Perfect!"};
      }
      float y = id(car_center_y).state;
      float target = (${target_y_min} + ${target_y_max}) / 2.0;
      if (y < target - 100) return {"â¬†ï¸ Move FORWARD"};
      if (y > target + 100) return {"â¬‡ï¸ Move BACK"};
      return {"ğŸ”„ Minor adjustment"};
    update_interval: 500ms

button:
  - platform: restart
    name: "Restart"

