# Car positioning sensor package
# Dual LD2450 mmWave radar sensors with LED parking guidance
#
# Required substitutions (define in main config):
#   ld2450_front_rx_pin: GPIO for front sensor RX (e.g., GPIO16)
#   ld2450_front_tx_pin: GPIO for front sensor TX (e.g., GPIO17)
#   ld2450_rear_rx_pin: GPIO for rear sensor RX (e.g., GPIO18)
#   ld2450_rear_tx_pin: GPIO for rear sensor TX (e.g., GPIO19)
#   led_strip_pin: GPIO for WS2812B data (e.g., GPIO0)
#   num_leds: Number of LEDs in strip (e.g., "30")
#   person_max_distance: Targets closer than this are likely people (mm)
#
# Sensor mounting and coordinate axes:
#   Front sensor (ceiling-mounted): Y = distance from ceiling to car top; X = lateral offset
#   Rear sensor (wall-mounted):     Y = distance from back wall into garage; X = height
#
# Per-sensor parking zone substitutions:
#   front_target_y_min / front_target_y_max: ceiling-to-car Y range (mm) — calibrate to ceiling_height - car_height ± tolerance
#   front_target_x_tolerance: max lateral offset (mm) from ceiling sensor X axis
#   rear_target_y_min / rear_target_y_max: parking depth from back wall (mm)
#   rear_target_x_tolerance: max X deviation for rear sensor (height axis — usually not critical)

uart:
  - id: uart_ld2450_front
    rx_pin: ${ld2450_front_rx_pin}
    tx_pin: ${ld2450_front_tx_pin}
    baud_rate: 256000
    parity: NONE
    stop_bits: 1
  - id: uart_ld2450_rear
    rx_pin: ${ld2450_rear_rx_pin}
    tx_pin: ${ld2450_rear_tx_pin}
    baud_rate: 256000
    parity: NONE
    stop_bits: 1

ld2450:
  - id: ld2450_front
    uart_id: uart_ld2450_front
  - id: ld2450_rear
    uart_id: uart_ld2450_rear

number:
  - platform: template
    name: "Car Position - LED Active Count"
    id: active_led_count
    icon: "mdi:led-on"
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 30
    restore_value: true
    optimistic: true
    set_action:
      - logger.log:
          format: "LED count set to %.0f"
          args: ['x']

sensor:
  # === FRONT SENSOR ===
  - platform: ld2450
    ld2450_id: ld2450_front
    target_count:
      name: "Car Position - Garage Door Target Count"
      id: front_target_count
    target_1:
      x:
        name: "Car Position - Garage Door X"
        id: front_x
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
      y:
        name: "Car Position - Garage Door Y"
        id: front_y
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
      distance:
        name: "Car Position - Garage Door Distance"
        id: front_distance
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
      speed:
        name: "Car Position - Garage Door Speed"
        id: front_speed
        unit_of_measurement: "in/s"
        accuracy_decimals: 1
        filters:
          - multiply: 0.3937

  # === REAR SENSOR ===
  - platform: ld2450
    ld2450_id: ld2450_rear
    target_count:
      name: "Car Position - Inside Wall Target Count"
      id: rear_target_count
    target_1:
      x:
        name: "Car Position - Inside Wall X"
        id: rear_x
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
      y:
        name: "Car Position - Inside Wall Y"
        id: rear_y
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
      distance:
        name: "Car Position - Inside Wall Distance"
        id: rear_distance
        unit_of_measurement: "in"
        accuracy_decimals: 1
        filters:
          - multiply: 0.03937
      speed:
        name: "Car Position - Inside Wall Speed"
        id: rear_speed
        unit_of_measurement: "in/s"
        accuracy_decimals: 1
        filters:
          - multiply: 0.3937

  # === COMPUTED POSITION ===
  # car_center_x: front (ceiling) sensor X — lateral offset of the car in inches.
  # Positive = one side, negative = other side (confirm direction by testing on hardware).
  # Falls back to rear X only when front is unavailable.
  - platform: template
    name: "Car Centering"
    id: car_center_x
    unit_of_measurement: "in"
    accuracy_decimals: 1
    icon: "mdi:car-side"
    lambda: |-
      bool front_valid = !isnan(id(front_distance).state) && id(front_distance).state > 0;
      bool rear_valid = !isnan(id(rear_distance).state) && id(rear_distance).state > 0;
      if (front_valid) return id(front_x).state;
      if (rear_valid) return id(rear_x).state;
      return NAN;
    update_interval: 500ms

  # car_center_y: rear (wall-mounted) sensor Y — distance from back wall into garage.
  # This is the physically meaningful depth axis for parking guidance.
  # Falls back to front Y only when rear is unavailable.
  - platform: template
    name: "Car Position - Distance from Inside Wall"
    id: car_center_y
    unit_of_measurement: "in"
    accuracy_decimals: 1
    icon: "mdi:car"
    lambda: |-
      bool rear_valid = !isnan(id(rear_distance).state) && id(rear_distance).state > 0;
      bool front_valid = !isnan(id(front_distance).state) && id(front_distance).state > 0;
      if (rear_valid) return id(rear_y).state;
      if (front_valid) return id(front_y).state;
      return NAN;
    update_interval: 500ms

binary_sensor:
  - platform: template
    name: "Car Position - Vehicle Detected"
    id: car_detected
    device_class: occupancy
    icon: "mdi:car"
    lambda: |-
      float front_dist = id(front_distance).state;
      float rear_dist = id(rear_distance).state;
      bool front_valid = !isnan(front_dist) && front_dist > 20;
      bool rear_valid = !isnan(rear_dist) && rear_dist > 20;
      return front_valid || rear_valid;
    filters:
      - delayed_on: 1s
      - delayed_off: 5s

  - platform: template
    name: "Car Position - Person Detected"
    id: person_detected
    device_class: motion
    icon: "mdi:walk"
    lambda: |-
      float front_dist = id(front_distance).state;
      float rear_dist = id(rear_distance).state;
      float front_spd = abs(id(front_speed).state);
      float rear_spd = abs(id(rear_speed).state);
      float max_dist = ${person_max_distance};
      bool front_person = !isnan(front_dist) && front_dist > 4 && front_dist < max_dist && front_spd < 20;
      bool rear_person = !isnan(rear_dist) && rear_dist > 4 && rear_dist < max_dist && rear_spd < 20;
      return (front_person || rear_person) && !id(car_detected).state;
    filters:
      - delayed_on: 500ms
      - delayed_off: 2s

  - platform: template
    name: "Car Position - Correctly Parked"
    id: car_correctly_parked
    device_class: occupancy
    icon: "mdi:car-select"
    lambda: |-
      if (!id(car_detected).state) return false;
      bool front_valid = !isnan(id(front_distance).state) && id(front_distance).state > 0;
      bool rear_valid  = !isnan(id(rear_distance).state)  && id(rear_distance).state  > 0;
      // Front sensor (ceiling): Y = ceiling-to-car-top distance; X = lateral offset
      bool front_ok = front_valid
        && (id(front_y).state >= ${front_target_y_min})
        && (id(front_y).state <= ${front_target_y_max})
        && abs(id(front_x).state) <= ${front_target_x_tolerance};
      // Rear sensor (wall): Y = depth from back wall
      bool rear_ok = rear_valid
        && (id(rear_y).state >= ${rear_target_y_min})
        && (id(rear_y).state <= ${rear_target_y_max});
      return front_ok && rear_ok;

text_sensor:
  - platform: template
    name: "Car Position - Parking Guidance"
    id: parking_guidance
    icon: "mdi:parking"
    lambda: |-
      if (id(person_detected).state) {
        return {"PERSON DETECTED"};
      }
      if (!id(car_detected).state) {
        return {"No vehicle"};
      }
      if (id(car_correctly_parked).state) {
        return {"PARKED"};
      }
      // Use rear sensor Y (wall-mounted) for depth guidance — measures parking distance from back wall
      float y = id(rear_y).state;
      if (isnan(y)) return {"Acquiring..."};
      float target = (${rear_target_y_min} + ${rear_target_y_max}) / 2.0;
      float zone = (${rear_target_y_max} - ${rear_target_y_min}) / 2.0;
      if (y < target - zone - 12) return {"MOVE FORWARD >>>"};
      if (y < target - zone) return {"Move forward >"};
      if (y > target + zone + 12) return {"<<< MOVE BACK"};
      if (y > target + zone) return {"< Move back"};
      return {"Almost there..."};
    update_interval: 500ms

light:
  - platform: esp32_rmt_led_strip
    name: "Car Position - LED Strip"
    id: garage_parking_led
    pin: ${led_strip_pin}
    num_leds: ${num_leds}
    chipset: WS2812
    restore_mode: ALWAYS_OFF
    rgb_order: GRB
    default_transition_length: 500ms
    effects:
      - addressable_lambda:
          name: "Parking Guidance"
          update_interval: 200ms
          lambda: |-
            int count = id(active_led_count).state;
            if (!id(car_detected).state) {
              for (int i = 0; i < it.size(); i++) it[i] = Color::BLACK;
            } else if (id(car_correctly_parked).state) {
              for (int i = 0; i < it.size(); i++)
                it[i] = (i < count) ? Color(0, 255, 0) : Color::BLACK;
            } else {
              // Use rear sensor Y (wall-mounted) for depth guidance
              float y = id(rear_y).state;
              if (isnan(y)) {
                for (int i = 0; i < it.size(); i++)
                  it[i] = (i < count) ? Color(128, 128, 128) : Color::BLACK;
                return;
              }
              float target = (${rear_target_y_min} + ${rear_target_y_max}) / 2.0;
              float zone = (${rear_target_y_max} - ${rear_target_y_min}) / 2.0;
              Color c;
              if (y < target - zone - 12) c = Color(0, 0, 255);
              else if (y > target + zone + 12) c = Color(255, 69, 0);
              else if (y < target - zone) c = Color(0, 255, 255);
              else if (y > target + zone) c = Color(255, 255, 0);
              else c = Color(255, 255, 255);
              for (int i = 0; i < it.size(); i++)
                it[i] = (i < count) ? c : Color::BLACK;
            }

      - addressable_lambda:
          name: "Solid"
          update_interval: 100ms
          lambda: |-
            int count = id(active_led_count).state;
            for (int i = 0; i < it.size(); i++)
              it[i] = (i < count) ? current_color : Color::BLACK;

      - addressable_lambda:
          name: "Parked (Green)"
          update_interval: 100ms
          lambda: |-
            int count = id(active_led_count).state;
            for (int i = 0; i < it.size(); i++)
              it[i] = (i < count) ? Color(0, 255, 0) : Color::BLACK;

      - addressable_lambda:
          name: "Move Forward (Blue Scan)"
          update_interval: 40ms
          lambda: |-
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;
            int pos = id(scan_position);
            int trail_length = 5;
            for (int i = 0; i < trail_length && (pos - i) >= 0; i++) {
              int idx = pos - i;
              if (idx < count) {
                uint8_t brightness = 255 - (i * 40);
                it[idx] = Color(0, 0, brightness);
              }
            }
            id(scan_position) = (pos + 1) % count;

      - addressable_lambda:
          name: "Move Forward Minor (Cyan Scan)"
          update_interval: 80ms
          lambda: |-
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;
            int pos = id(scan_position);
            int trail_length = 3;
            for (int i = 0; i < trail_length && (pos - i) >= 0; i++) {
              int idx = pos - i;
              if (idx < count) {
                uint8_t brightness = 255 - (i * 60);
                it[idx] = Color(0, brightness, brightness);
              }
            }
            id(scan_position) = (pos + 1) % count;

      - addressable_lambda:
          name: "Move Back (Orange Scan)"
          update_interval: 40ms
          lambda: |-
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;
            int pos = id(scan_position);
            int trail_length = 5;
            for (int i = 0; i < trail_length && (pos + i) < count; i++) {
              int idx = pos + i;
              if (idx >= 0) {
                uint8_t brightness = 255 - (i * 40);
                it[idx] = Color(brightness, brightness / 4, 0);
              }
            }
            id(scan_position) = pos - 1;
            if (id(scan_position) < 0) id(scan_position) = count - 1;

      - addressable_lambda:
          name: "Move Back Minor (Yellow Scan)"
          update_interval: 80ms
          lambda: |-
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;
            int pos = id(scan_position);
            int trail_length = 3;
            for (int i = 0; i < trail_length && (pos + i) < count; i++) {
              int idx = pos + i;
              if (idx >= 0) {
                uint8_t brightness = 255 - (i * 60);
                it[idx] = Color(brightness, brightness, 0);
              }
            }
            id(scan_position) = pos - 1;
            if (id(scan_position) < 0) id(scan_position) = count - 1;

      - addressable_lambda:
          name: "Person Alert (Red Flash)"
          update_interval: 250ms
          lambda: |-
            static bool flash_on = false;
            int count = id(active_led_count).state;
            flash_on = !flash_on;
            Color c = flash_on ? Color(255, 0, 0) : Color::BLACK;
            for (int i = 0; i < it.size(); i++)
              it[i] = (i < count) ? c : Color::BLACK;

      - addressable_lambda:
          name: "Rainbow"
          update_interval: 50ms
          lambda: |-
            static int offset = 0;
            int count = id(active_led_count).state;
            for (int i = 0; i < it.size(); i++) {
              if (i < count) {
                int hue = (i * 255 / count + offset) % 256;
                int region = hue / 43;
                int remainder = (hue - (region * 43)) * 6;
                uint8_t q = 255 - remainder;
                uint8_t t = remainder;
                uint8_t r, g, b;
                switch (region) {
                  case 0: r = 255; g = t; b = 0; break;
                  case 1: r = q; g = 255; b = 0; break;
                  case 2: r = 0; g = 255; b = t; break;
                  case 3: r = 0; g = q; b = 255; break;
                  case 4: r = t; g = 0; b = 255; break;
                  default: r = 255; g = 0; b = q; break;
                }
                it[i] = Color(r, g, b);
              } else {
                it[i] = Color::BLACK;
              }
            }
            offset = (offset + 2) % 256;

      - pulse:
          name: "Pulse"
          min_brightness: 20%
          max_brightness: 100%
