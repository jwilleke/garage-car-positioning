# Car positioning sensor package
# Dual LD2450 mmWave radar sensors with LED parking guidance
#
# Required substitutions (define in main config):
#   ld2450_front_rx_pin: GPIO for front sensor RX (e.g., GPIO16)
#   ld2450_front_tx_pin: GPIO for front sensor TX (e.g., GPIO17)
#   ld2450_rear_rx_pin: GPIO for rear sensor RX (e.g., GPIO18)
#   ld2450_rear_tx_pin: GPIO for rear sensor TX (e.g., GPIO19)
#   led_strip_pin: GPIO for WS2812B data (e.g., GPIO0)
#   num_leds: Number of LEDs in strip (e.g., "30")
#   target_y_min: Minimum Y position for correct parking (mm)
#   target_y_max: Maximum Y position for correct parking (mm)
#   target_x_tolerance: Maximum X deviation from center (mm)
#   person_max_distance: Targets closer than this are likely people (mm)

uart:
  - id: uart_ld2450_front
    rx_pin: ${ld2450_front_rx_pin}
    tx_pin: ${ld2450_front_tx_pin}
    baud_rate: 256000
    parity: NONE
    stop_bits: 1
  - id: uart_ld2450_rear
    rx_pin: ${ld2450_rear_rx_pin}
    tx_pin: ${ld2450_rear_tx_pin}
    baud_rate: 256000
    parity: NONE
    stop_bits: 1

ld2450:
  - id: ld2450_front
    uart_id: uart_ld2450_front
  - id: ld2450_rear
    uart_id: uart_ld2450_rear

number:
  - platform: template
    name: "Car Position - LED Active Count"
    id: active_led_count
    icon: "mdi:led-on"
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 30
    restore_value: true
    optimistic: true
    set_action:
      - logger.log:
          format: "LED count set to %.0f"
          args: ['x']

sensor:
  # === FRONT SENSOR ===
  - platform: ld2450
    ld2450_id: ld2450_front
    target_count:
      name: "Car Position - Front Target Count"
      id: front_target_count
    target_1:
      x:
        name: "Car Position - Front X"
        id: front_x
        unit_of_measurement: "mm"
      y:
        name: "Car Position - Front Y"
        id: front_y
        unit_of_measurement: "mm"
      distance:
        name: "Car Position - Front Distance"
        id: front_distance
        unit_of_measurement: "mm"
      speed:
        name: "Car Position - Front Speed"
        id: front_speed
        unit_of_measurement: "cm/s"

  # === REAR SENSOR ===
  - platform: ld2450
    ld2450_id: ld2450_rear
    target_count:
      name: "Car Position - Rear Target Count"
      id: rear_target_count
    target_1:
      x:
        name: "Car Position - Rear X"
        id: rear_x
        unit_of_measurement: "mm"
      y:
        name: "Car Position - Rear Y"
        id: rear_y
        unit_of_measurement: "mm"
      distance:
        name: "Car Position - Rear Distance"
        id: rear_distance
        unit_of_measurement: "mm"
      speed:
        name: "Car Position - Rear Speed"
        id: rear_speed
        unit_of_measurement: "cm/s"

  # === COMPUTED POSITION ===
  - platform: template
    name: "Car Position - Center X"
    id: car_center_x
    unit_of_measurement: "mm"
    lambda: |-
      bool front_valid = !isnan(id(front_distance).state) && id(front_distance).state > 0;
      bool rear_valid = !isnan(id(rear_distance).state) && id(rear_distance).state > 0;
      if (front_valid && rear_valid) {
        return (id(front_x).state + id(rear_x).state) / 2.0;
      } else if (front_valid) {
        return id(front_x).state;
      } else if (rear_valid) {
        return id(rear_x).state;
      }
      return NAN;
    update_interval: 500ms

  - platform: template
    name: "Car Position - Center Y"
    id: car_center_y
    unit_of_measurement: "mm"
    icon: "mdi:car"
    lambda: |-
      bool front_valid = !isnan(id(front_distance).state) && id(front_distance).state > 0;
      bool rear_valid = !isnan(id(rear_distance).state) && id(rear_distance).state > 0;
      if (front_valid && rear_valid) {
        return (id(front_y).state + id(rear_y).state) / 2.0;
      } else if (front_valid) {
        return id(front_y).state;
      } else if (rear_valid) {
        return id(rear_y).state;
      }
      return NAN;
    update_interval: 500ms

binary_sensor:
  - platform: template
    name: "Car Position - Vehicle Detected"
    id: car_detected
    device_class: occupancy
    icon: "mdi:car"
    lambda: |-
      float front_dist = id(front_distance).state;
      float rear_dist = id(rear_distance).state;
      bool front_valid = !isnan(front_dist) && front_dist > 500;
      bool rear_valid = !isnan(rear_dist) && rear_dist > 500;
      return front_valid || rear_valid;
    filters:
      - delayed_on: 1s
      - delayed_off: 5s

  - platform: template
    name: "Car Position - Person Detected"
    id: person_detected
    device_class: motion
    icon: "mdi:walk"
    lambda: |-
      float front_dist = id(front_distance).state;
      float rear_dist = id(rear_distance).state;
      float front_spd = abs(id(front_speed).state);
      float rear_spd = abs(id(rear_speed).state);
      float max_dist = ${person_max_distance};
      bool front_person = !isnan(front_dist) && front_dist > 100 && front_dist < max_dist && front_spd < 50;
      bool rear_person = !isnan(rear_dist) && rear_dist > 100 && rear_dist < max_dist && rear_spd < 50;
      return (front_person || rear_person) && !id(car_detected).state;
    filters:
      - delayed_on: 500ms
      - delayed_off: 2s

  - platform: template
    name: "Car Position - Correctly Parked"
    id: car_correctly_parked
    device_class: occupancy
    icon: "mdi:car-select"
    lambda: |-
      if (!id(car_detected).state) return false;
      float y = id(car_center_y).state;
      float x = id(car_center_x).state;
      if (isnan(y) || isnan(x)) return false;
      bool y_ok = (y >= ${target_y_min}) && (y <= ${target_y_max});
      bool x_ok = abs(x) <= ${target_x_tolerance};
      return y_ok && x_ok;

text_sensor:
  - platform: template
    name: "Car Position - Parking Guidance"
    id: parking_guidance
    icon: "mdi:parking"
    lambda: |-
      if (id(person_detected).state) {
        return {"PERSON DETECTED"};
      }
      if (!id(car_detected).state) {
        return {"No vehicle"};
      }
      if (id(car_correctly_parked).state) {
        return {"PARKED"};
      }
      float y = id(car_center_y).state;
      if (isnan(y)) return {"Acquiring..."};
      float target = (${target_y_min} + ${target_y_max}) / 2.0;
      float zone = (${target_y_max} - ${target_y_min}) / 2.0;
      if (y < target - zone - 300) return {"MOVE FORWARD >>>"};
      if (y < target - zone) return {"Move forward >"};
      if (y > target + zone + 300) return {"<<< MOVE BACK"};
      if (y > target + zone) return {"< Move back"};
      return {"Almost there..."};
    update_interval: 500ms

light:
  - platform: esp32_rmt_led_strip
    name: "Car Position - LED Strip"
    id: garage_parking_led
    pin: ${led_strip_pin}
    num_leds: ${num_leds}
    chipset: WS2812
    restore_mode: ALWAYS_OFF
    rgb_order: GRB
    default_transition_length: 500ms
    effects:
      - addressable_lambda:
          name: "Parking Guidance"
          update_interval: 200ms
          lambda: |-
            int count = id(active_led_count).state;
            if (!id(car_detected).state) {
              for (int i = 0; i < it.size(); i++) it[i] = Color::BLACK;
            } else if (id(car_correctly_parked).state) {
              for (int i = 0; i < it.size(); i++)
                it[i] = (i < count) ? Color(0, 255, 0) : Color::BLACK;
            } else {
              float y = id(car_center_y).state;
              if (isnan(y)) {
                for (int i = 0; i < it.size(); i++)
                  it[i] = (i < count) ? Color(128, 128, 128) : Color::BLACK;
                return;
              }
              float target = (${target_y_min} + ${target_y_max}) / 2.0;
              float zone = (${target_y_max} - ${target_y_min}) / 2.0;
              Color c;
              if (y < target - zone - 300) c = Color(0, 0, 255);
              else if (y > target + zone + 300) c = Color(255, 69, 0);
              else if (y < target - zone) c = Color(0, 255, 255);
              else if (y > target + zone) c = Color(255, 255, 0);
              else c = Color(255, 255, 255);
              for (int i = 0; i < it.size(); i++)
                it[i] = (i < count) ? c : Color::BLACK;
            }

      - addressable_lambda:
          name: "Solid"
          update_interval: 100ms
          lambda: |-
            int count = id(active_led_count).state;
            for (int i = 0; i < it.size(); i++)
              it[i] = (i < count) ? current_color : Color::BLACK;

      - addressable_lambda:
          name: "Parked (Green)"
          update_interval: 100ms
          lambda: |-
            int count = id(active_led_count).state;
            for (int i = 0; i < it.size(); i++)
              it[i] = (i < count) ? Color(0, 255, 0) : Color::BLACK;

      - addressable_lambda:
          name: "Move Forward (Blue Scan)"
          update_interval: 40ms
          lambda: |-
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;
            int pos = id(scan_position);
            int trail_length = 5;
            for (int i = 0; i < trail_length && (pos - i) >= 0; i++) {
              int idx = pos - i;
              if (idx < count) {
                uint8_t brightness = 255 - (i * 40);
                it[idx] = Color(0, 0, brightness);
              }
            }
            id(scan_position) = (pos + 1) % count;

      - addressable_lambda:
          name: "Move Forward Minor (Cyan Scan)"
          update_interval: 80ms
          lambda: |-
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;
            int pos = id(scan_position);
            int trail_length = 3;
            for (int i = 0; i < trail_length && (pos - i) >= 0; i++) {
              int idx = pos - i;
              if (idx < count) {
                uint8_t brightness = 255 - (i * 60);
                it[idx] = Color(0, brightness, brightness);
              }
            }
            id(scan_position) = (pos + 1) % count;

      - addressable_lambda:
          name: "Move Back (Orange Scan)"
          update_interval: 40ms
          lambda: |-
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;
            int pos = id(scan_position);
            int trail_length = 5;
            for (int i = 0; i < trail_length && (pos + i) < count; i++) {
              int idx = pos + i;
              if (idx >= 0) {
                uint8_t brightness = 255 - (i * 40);
                it[idx] = Color(brightness, brightness / 4, 0);
              }
            }
            id(scan_position) = pos - 1;
            if (id(scan_position) < 0) id(scan_position) = count - 1;

      - addressable_lambda:
          name: "Move Back Minor (Yellow Scan)"
          update_interval: 80ms
          lambda: |-
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;
            int pos = id(scan_position);
            int trail_length = 3;
            for (int i = 0; i < trail_length && (pos + i) < count; i++) {
              int idx = pos + i;
              if (idx >= 0) {
                uint8_t brightness = 255 - (i * 60);
                it[idx] = Color(brightness, brightness, 0);
              }
            }
            id(scan_position) = pos - 1;
            if (id(scan_position) < 0) id(scan_position) = count - 1;

      - addressable_lambda:
          name: "Person Alert (Red Flash)"
          update_interval: 250ms
          lambda: |-
            static bool flash_on = false;
            int count = id(active_led_count).state;
            flash_on = !flash_on;
            Color c = flash_on ? Color(255, 0, 0) : Color::BLACK;
            for (int i = 0; i < it.size(); i++)
              it[i] = (i < count) ? c : Color::BLACK;

      - addressable_lambda:
          name: "Rainbow"
          update_interval: 50ms
          lambda: |-
            static int offset = 0;
            int count = id(active_led_count).state;
            for (int i = 0; i < it.size(); i++) {
              if (i < count) {
                int hue = (i * 255 / count + offset) % 256;
                int region = hue / 43;
                int remainder = (hue - (region * 43)) * 6;
                uint8_t q = 255 - remainder;
                uint8_t t = remainder;
                uint8_t r, g, b;
                switch (region) {
                  case 0: r = 255; g = t; b = 0; break;
                  case 1: r = q; g = 255; b = 0; break;
                  case 2: r = 0; g = 255; b = t; break;
                  case 3: r = 0; g = q; b = 255; break;
                  case 4: r = t; g = 0; b = 255; break;
                  default: r = 255; g = 0; b = q; break;
                }
                it[i] = Color(r, g, b);
              } else {
                it[i] = Color::BLACK;
              }
            }
            offset = (offset + 2) % 256;

      - pulse:
          name: "Pulse"
          min_brightness: 20%
          max_brightness: 100%
