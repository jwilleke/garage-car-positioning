substitutions:
  device_name: simple-wifi-test
  friendly_name: "Simple WiFi Test"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  # Version marker - update this when making changes
  comment: "GPIO1/2/3 Sensors + WS2812B LED Strip - v1.5 - 2026-01-18"
  on_boot:
    priority: -100
    then:
      - lambda: |-
          id(boot_count) += 1;
          ESP_LOGI("boot", "Boot count: %d", id(boot_count));
      - light.turn_off: led_strip

# Persistent boot counter
globals:
  - id: boot_count
    type: int
    restore_value: true
    initial_value: '0'

esp32:
  board: esp32-c6-devkitc-1
  variant: esp32c6
  framework:
    type: esp-idf
    version: recommended

logger:
  level: DEBUG
  hardware_uart: USB_SERIAL_JTAG

# AP-only mode - no station connection attempts
wifi:
  ap:
    ssid: "simple-wifi-test"
    password: "test1234"

api:
  # Disable reboot when Home Assistant isn't connected
  # Set to 15min (default) when using with Home Assistant
  reboot_timeout: 0s

ota:
  - platform: esphome
    password: "test1234"

web_server:
  port: 80
  version: 3
  include_internal: false

# Add a simple sensor so web interface has something to display
sensor:
  - platform: uptime
    name: "Uptime Seconds"
    id: uptime_sensor
    internal: true  # Hide raw seconds from portal

  - platform: template
    name: "Boot Count"
    id: boot_count_sensor
    accuracy_decimals: 0
    lambda: |-
      return id(boot_count);
    update_interval: 60s

# LED count slider - adjustable from portal
number:
  - platform: template
    name: "Active LED Count"
    id: active_led_count
    min_value: 1
    max_value: 144
    step: 1
    initial_value: 30
    restore_value: true
    optimistic: true
    set_action:
      - logger.log:
          format: "LED count set to %.0f"
          args: ['x']

# MOVED FROM GPIO 4,5,6 (JTAG pins) to GPIO 1,2,3 (stable LP pins)
# See hardware/ESP32-C6 DevKit.md for details on JTAG interference

# Component Test: GPIO1 - Closed Door Reed Switch (was GPIO4)
# Wiring: Connect one leg to GPIO1, other leg to GND
# Expected: Switch OPEN when door is OPEN, CLOSED when door is CLOSED
binary_sensor:
  - platform: gpio
    name: "Garage Door Closed Switch"
    id: garage_door_closed_switch
    pin:
      number: GPIO1
      mode: INPUT_PULLUP
      inverted: true
    device_class: door
    on_press:
      - logger.log:
          format: "*** GPIO1: Door switch PRESSED (Door CLOSED) ***"
          level: INFO
    on_release:
      - logger.log:
          format: "*** GPIO1: Door switch RELEASED (Door OPEN) ***"
          level: INFO
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms

  # Component Test: GPIO2 - Hall Effect Sensor A (NJK-5002C) (was GPIO5)
  # Wiring: Brown=5V, Blue=GND, Black=GPIO2
  # NPN Normally Open: No magnet=HIGH, Magnet detected=LOW
  - platform: gpio
    name: "Hall Effect Sensor A"
    id: hall_sensor_a
    pin:
      number: GPIO2
      mode: INPUT_PULLUP
      inverted: true  # Invert so ON=magnet detected
    device_class: occupancy
    on_press:
      - logger.log:
          format: "*** GPIO2: Hall Sensor A TRIGGERED (magnet detected) ***"
          level: INFO
    on_release:
      - logger.log:
          format: "*** GPIO2: Hall Sensor A CLEARED (no magnet) ***"
          level: INFO
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms

  # Component Test: GPIO3 - Hall Effect Sensor B (NJK-5002C) (was GPIO6)
  # Wiring: Brown=5V, Blue=GND, Black=GPIO3
  # NPN Normally Open: No magnet=HIGH, Magnet detected=LOW
  - platform: gpio
    name: "Hall Effect Sensor B"
    id: hall_sensor_b
    pin:
      number: GPIO3
      mode: INPUT_PULLUP
      inverted: true  # Invert so ON=magnet detected
    device_class: occupancy
    on_press:
      - logger.log:
          format: "*** GPIO3: Hall Sensor B TRIGGERED (magnet detected) ***"
          level: INFO
    on_release:
      - logger.log:
          format: "*** GPIO3: Hall Sensor B CLEARED (no magnet) ***"
          level: INFO
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms

button:
  - platform: restart
    name: "Restart Device"

# Component Test: GPIO0 - WS2812B LED Strip
# Wiring: External 5V PSU to VCC, GND shared with ESP32, DIN to GPIO0
light:
  - platform: esp32_rmt_led_strip
    name: "LED Strip"
    id: led_strip
    pin: GPIO0
    num_leds: 144
    chipset: WS2812
    restore_mode: ALWAYS_OFF
    rgb_order: GRB
    default_transition_length: 500ms
    effects:
      - addressable_lambda:
          name: "Solid (Active LEDs)"
          update_interval: 100ms
          lambda: |-
            int count = id(active_led_count).state;
            for (int i = 0; i < it.size(); i++) {
              if (i < count) {
                it[i] = current_color;
              } else {
                it[i] = Color::BLACK;
              }
            }
      - addressable_lambda:
          name: "Rainbow (Active LEDs)"
          update_interval: 50ms  # Was 16ms - reduced to prevent task watchdog
          lambda: |-
            static int offset = 0;
            int count = id(active_led_count).state;
            for (int i = 0; i < it.size(); i++) {
              if (i < count) {
                int hue = (i * 255 / count + offset) % 256;
                // HSV to RGB conversion (S=255, V=255)
                int region = hue / 43;
                int remainder = (hue - (region * 43)) * 6;
                uint8_t p = 0;
                uint8_t q = 255 - remainder;
                uint8_t t = remainder;
                uint8_t r, g, b;
                switch (region) {
                  case 0: r = 255; g = t; b = 0; break;
                  case 1: r = q; g = 255; b = 0; break;
                  case 2: r = 0; g = 255; b = t; break;
                  case 3: r = 0; g = q; b = 255; break;
                  case 4: r = t; g = 0; b = 255; break;
                  default: r = 255; g = 0; b = q; break;
                }
                it[i] = Color(r, g, b);
              } else {
                it[i] = Color::BLACK;
              }
            }
            offset = (offset + 2) % 256;
      - addressable_lambda:
          name: "Scan (Active LEDs)"
          update_interval: 50ms
          lambda: |-
            static int pos = 0;
            static bool forward = true;
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;
            for (int i = 0; i < 3 && (pos + i) < count; i++) {
              it[pos + i] = current_color;
            }
            if (forward) {
              pos++;
              if (pos >= count - 2) forward = false;
            } else {
              pos--;
              if (pos <= 0) forward = true;
            }
      - pulse:
          name: "Pulse"
          min_brightness: 20%
          max_brightness: 100%

# Status text sensors
text_sensor:
  - platform: wifi_info
    mac_address:
      name: "MAC Address"

  - platform: template
    name: "Reset Reason"
    id: reset_reason_sensor
    lambda: |-
      switch (esp_reset_reason()) {
        case ESP_RST_POWERON: return std::string("Power-on");
        case ESP_RST_EXT: return std::string("External pin");
        case ESP_RST_SW: return std::string("Software reset");
        case ESP_RST_PANIC: return std::string("Exception/panic");
        case ESP_RST_INT_WDT: return std::string("Interrupt watchdog");
        case ESP_RST_TASK_WDT: return std::string("Task watchdog");
        case ESP_RST_WDT: return std::string("Other watchdog");
        case ESP_RST_DEEPSLEEP: return std::string("Deep sleep wake");
        case ESP_RST_BROWNOUT: return std::string("Brownout");
        case ESP_RST_SDIO: return std::string("SDIO");
        default: return std::string("Unknown");
      }
    update_interval: never

  - platform: template
    name: "Uptime"
    lambda: |-
      int seconds = (int) id(uptime_sensor).state;
      int weeks = seconds / 604800;
      seconds = seconds % 604800;
      int days = seconds / 86400;
      seconds = seconds % 86400;
      int hours = seconds / 3600;
      seconds = seconds % 3600;
      int minutes = seconds / 60;
      if (weeks > 0) {
        return str_sprintf("%dw %dd %dh %dm", weeks, days, hours, minutes);
      } else if (days > 0) {
        return str_sprintf("%dd %dh %dm", days, hours, minutes);
      } else if (hours > 0) {
        return str_sprintf("%dh %dm", hours, minutes);
      } else {
        return str_sprintf("%dm", minutes);
      }
    update_interval: 60s