substitutions:
  device_name: simple-wifi-test
  friendly_name: "Simple WiFi Test"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  # Version marker - update this when making changes
  comment: "GPIO4 Switch + Hall Effect Sensors + WS2812B LED Strip - v1.3 - 2026-01-16"

esp32:
  board: esp32-c6-devkitc-1
  variant: esp32c6
  framework:
    type: esp-idf
    version: recommended

logger:
  level: DEBUG
  hardware_uart: USB_SERIAL_JTAG

# AP-only mode - no station connection attempts
wifi:
  ap:
    ssid: "simple-wifi-test"
    password: "test1234"

api:
  # API might be required for web server to work properly

ota:
  - platform: esphome
    password: "test1234"

web_server:
  port: 80
  # version: 2  # Try default version first
  include_internal: false

# Add a simple sensor so web interface has something to display
sensor:
  - platform: uptime
    name: "Uptime"

# LED count slider - adjustable from portal
number:
  - platform: template
    name: "Active LED Count"
    id: active_led_count
    min_value: 1
    max_value: 144
    step: 1
    initial_value: 30
    restore_value: true
    optimistic: true

# Component Test: GPIO4 - Closed Door Reed Switch
# Wiring: Connect one leg to GPIO4, other leg to GND
# Expected: Switch OPEN when door is OPEN, CLOSED when door is CLOSED
binary_sensor:
  - platform: gpio
    name: "Garage Door Closed Switch"
    id: garage_door_closed_switch
    pin:
      number: GPIO4
      mode: INPUT_PULLUP
      inverted: true
    device_class: door
    on_press:
      - logger.log:
          format: "*** GPIO4: Door switch PRESSED (Door CLOSED) ***"
          level: INFO
    on_release:
      - logger.log:
          format: "*** GPIO4: Door switch RELEASED (Door OPEN) ***"
          level: INFO
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms

  # Component Test: GPIO5 - Hall Effect Sensor A (NJK-5002C)
  # Wiring: Brown=5V, Blue=GND, Black=GPIO5
  # NPN Normally Open: No magnet=HIGH, Magnet detected=LOW
  - platform: gpio
    name: "Hall Effect Sensor A"
    id: hall_sensor_a
    pin:
      number: GPIO5
      mode: INPUT_PULLUP
      inverted: true  # Invert so ON=magnet detected
    device_class: occupancy
    on_press:
      - logger.log:
          format: "*** GPIO5: Hall Sensor A TRIGGERED (magnet detected) ***"
          level: INFO
    on_release:
      - logger.log:
          format: "*** GPIO5: Hall Sensor A CLEARED (no magnet) ***"
          level: INFO
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms

  # Component Test: GPIO6 - Hall Effect Sensor B (NJK-5002C)
  # Wiring: Brown=5V, Blue=GND, Black=GPIO6
  # NPN Normally Open: No magnet=HIGH, Magnet detected=LOW
  - platform: gpio
    name: "Hall Effect Sensor B"
    id: hall_sensor_b
    pin:
      number: GPIO6
      mode: INPUT_PULLUP
      inverted: true  # Invert so ON=magnet detected
    device_class: occupancy
    on_press:
      - logger.log:
          format: "*** GPIO6: Hall Sensor B TRIGGERED (magnet detected) ***"
          level: INFO
    on_release:
      - logger.log:
          format: "*** GPIO6: Hall Sensor B CLEARED (no magnet) ***"
          level: INFO
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms

button:
  - platform: restart
    name: "Restart Device"

# Component Test: GPIO0 - WS2812B LED Strip
# Wiring: External 5V PSU to VCC, GND shared with ESP32, DIN to GPIO0
light:
  - platform: esp32_rmt_led_strip
    name: "LED Strip"
    id: led_strip
    pin: GPIO0
    num_leds: 144
    chipset: WS2812
    rgb_order: GRB
    default_transition_length: 500ms
    effects:
      - addressable_lambda:
          name: "Solid (Active LEDs)"
          update_interval: 100ms
          lambda: |-
            int count = id(active_led_count).state;
            for (int i = 0; i < it.size(); i++) {
              if (i < count) {
                it[i] = current_color;
              } else {
                it[i] = Color::BLACK;
              }
            }
      - addressable_lambda:
          name: "Rainbow (Active LEDs)"
          update_interval: 16ms
          lambda: |-
            static int offset = 0;
            int count = id(active_led_count).state;
            for (int i = 0; i < it.size(); i++) {
              if (i < count) {
                int hue = (i * 255 / count + offset) % 256;
                // HSV to RGB conversion (S=255, V=255)
                int region = hue / 43;
                int remainder = (hue - (region * 43)) * 6;
                uint8_t p = 0;
                uint8_t q = 255 - remainder;
                uint8_t t = remainder;
                uint8_t r, g, b;
                switch (region) {
                  case 0: r = 255; g = t; b = 0; break;
                  case 1: r = q; g = 255; b = 0; break;
                  case 2: r = 0; g = 255; b = t; break;
                  case 3: r = 0; g = q; b = 255; break;
                  case 4: r = t; g = 0; b = 255; break;
                  default: r = 255; g = 0; b = q; break;
                }
                it[i] = Color(r, g, b);
              } else {
                it[i] = Color::BLACK;
              }
            }
            offset = (offset + 2) % 256;
      - addressable_lambda:
          name: "Scan (Active LEDs)"
          update_interval: 50ms
          lambda: |-
            static int pos = 0;
            static bool forward = true;
            int count = id(active_led_count).state;
            it.all() = Color::BLACK;
            for (int i = 0; i < 3 && (pos + i) < count; i++) {
              it[pos + i] = current_color;
            }
            if (forward) {
              pos++;
              if (pos >= count - 2) forward = false;
            } else {
              pos--;
              if (pos <= 0) forward = true;
            }
      - pulse:
          name: "Pulse"
          min_brightness: 20%
          max_brightness: 100%

# Status text sensor
text_sensor:
  - platform: wifi_info
    mac_address:
      name: "MAC Address"